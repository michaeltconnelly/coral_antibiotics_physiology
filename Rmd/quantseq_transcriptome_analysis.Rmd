---
title: "quantseq_transcriptome_analysis"
author: "Mike Connelly"
date: "1/11/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
options(stringsAsFactors = FALSE)
```

## Setup packages and working directories
```{r packages, message=FALSE, include=FALSE}
# Include all packages needed for the entire transcriptome analysis and downstream visualizations
library("tidyverse")
# Essential RNAseq analysis packages
library("DESeq2")
library("apeglm")
library("WGCNA")
library("dynamicTreeCut")
library("flashClust")
library("genefilter")
# library("variancePartition")
# library("doParallel")
# library("limma")
# library("adegenet")
# GO/KOG enrichment packages and other functions
library("KOGMWU")
source("./R/GO_MWU/gomwu.functions.R")
# Data visualization packages
library("pheatmap")
library("ComplexHeatmap")
library("VennDiagram")
library("eulerr")
library("UpSetR")
# Graphics packages
# library("cowplot")
library("patchwork")
library("gridExtra")
library("ggthemes")
library("ggpubr")
library("ggrepel")
library("ggnewscale")
library("RColorBrewer")
library("circlize")
library("stringr")
library("extrafont")
library("extrafontdb")
# extended visualization functions
source("./R/AXH_functions.R")
```
```{r colors}
### Set overall theme, colors, and shapes for ggplot2
# colors for experimental treatments
treatcolors <- c("lightblue", "dodgerblue", "seagreen1")
shapes <- c(15:20) # may be useful for genotype variables: Gulf, Location, mtORF, symbiont, etc.
# colors for genotypes
genotype_colors <- read_csv("data/genotype_colors.csv") #%>%
  # dplyr::filter(Genotype %in% c("PAN-78", "PAN-79", "PAN-83"))# color names csv corresponding to excel sheet colors
genocolors <- c(genotype_colors$color) # default ggplot fill may also work in this case
# null colors for presentation figures
condcolors_null <- c(rep("black", 3))
colshapes_null <- c(rep(20, 8))
# differential gene expression volcano plot point colors
DEGcolors <- c("red", "blue", "dark grey")
# Create sample heatmap cell color
colonyclustercol <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
# Create gene expression cell color
paletteLength <- 100
# Red --> Blue gradient
geneexpcolors <- colorRampPalette(rev(c("red", "yellow", "white", "cyan", "blue")))(paletteLength)
# Orange --> Cyan gradient
geneexpcolors1 <- colorRampPalette(rev(c("chocolate1","#FEE090","grey10", "cyan3","cyan")))(paletteLength)
# Red --> Blue dark gradient
geneexpcolors2 <- colorRampPalette(rev(c("red", "yellow", "grey10", "cyan", "blue")))(paletteLength)
# Color bars to preview
#color.bar(geneexpcolors, -1, 1)
#color.bar(geneexpcolors1, -1, 1)
#color.bar(geneexpcolors2, -1, 1)
```
```{r theme}
theme_set(theme_mec())
#image widths: 80 mm (one column), 112 mm (two-thirds page), 169 mm (two columns)
# pdf.options(family = "ArialMT")
# postscript(family = "ArialMT")
```

## Import sample metadata
```{r genotypes_fragments}
genotypes <- read_csv("data/genotypes.csv")
#
fragments <- read_csv("data/fragments.csv", col_types = cols(
  Fragment_ID = col_character()))
```
```{r factors}
# factor levels
# treatment_levels <- c("Baseline", "Control", "Antibiotics", "FSW_Controls", "SW_Controls", "Neg_Controls", "ZYMO_Controls")
sampling_levels <- c("Day 0", "Day 7")
genotype_levels <- c("PAN-05", "PAN-10", "PAN-32", "PAN-34", "PAN-35", "PAN-37", "PAN-39", "PAN-41", "PAN-43","PAN-44", "PAN-78", "PAN-79", "PAN-83", "URA-51", NA)
gulf_levels <- c("Chiriqui", "Panama")
loc_levels <- c("Uva", "Saboga", "Uraba")
mtorf_levels <- c("Type_1", "Type_3")#, "unknown")
sym_levels <- c("C1bc", "C1d", "D1")#, "unknown")
genus_levels <- c("Cladocopium", "Durusdinium")
```
```{r  sample_data, echo=TRUE}
# Import sample metadata 
sample_metadata <- read_delim("./data/quantseq_metadata.tsv", delim ="\t", col_names = c("Sample_ID", "Genotype", "Treatment", "Sampling_Time", "Sequencing_Success", "Sequencing_Round"), comment = "#")#, row.names = 1, header = FALSE)
# join with genotype metadata
sample_metadata <- sample_metadata %>% left_join(genotypes, by = "Genotype")
# Set factor orders
sample_metadata$Genotype <- factor(sample_metadata$Genotype, levels = genotype_levels, ordered = TRUE)
# sample_metadata$Treatment <- factor(sample_metadata$Treatment, levels = treatment_levels, ordered = TRUE)
sample_metadata$Gulf <- factor(sample_metadata$Gulf, levels = gulf_levels, ordered = TRUE)
sample_metadata$Location <- factor(sample_metadata$Location, levels = loc_levels, ordered = TRUE)
sample_metadata$mtORF <- factor(sample_metadata$mtORF, levels = mtorf_levels, ordered = TRUE)
sample_metadata$ITS2 <- factor(sample_metadata$ITS2, levels = sym_levels, ordered = TRUE)
sample_metadata$Symbiont_Genus <- ifelse(sample_metadata$ITS2 == "D1", "Durusdinium", "Cladocopium")
# Create phyloseq-compatible sample map
samples <- sample_metadata %>%
  dplyr::filter(Sequencing_Success == T) #%>%
  # dplyr::select(Sample_ID, Genotype, Treatment, Gulf, mtORF, ITS2, Symbiont_Genus) #%>% 
```
```{r coldata}
# Get sample data into tibble
coldata <- samples %>%
  as_tibble(.) %>%
  mutate(Genotype.Treatment = interaction(Genotype, Treatment)) %>%
  mutate_if(is.character, as.factor) %>% 
  dplyr::arrange("Sample_ID") %>% #Order rows by sample name                         
  column_to_rownames(var = "Sample_ID")  
```

## Import *Pocillopora* coral counts data and gene annotation
```{r coral_countdata}
# Import and tidy counts data
# countdata <- read.delim("./outputs/STARcounts_Pdam/PocAnti_Pdam.counts", comment.char="#")
countdata <- read.delim("./outputs/tagseq/STARcounts_Pdam/PocAnti_Pdam_Round2.counts", comment.char="#")
# Set Gene ID's as row names
row.names(countdata) <- countdata$Geneid
# Remove first six columns (Geneid, chr, start, end, strand, length)
countdata <- countdata[ ,7:ncol(countdata)]
#countdata <- countdata[ ,6:ncol(countdata)]
# Remove file prefixes and suffixes
  colnames(countdata) <- gsub("X.", "", colnames(countdata))
  colnames(countdata) <- gsub("scratch.projects.transcriptomics.mikeconnelly.projects.anti_phys.outputs.STARalign_Pdam.", "", colnames(countdata))
  colnames(countdata) <- gsub("_Aligned.sortedByCoord.out.uniq.bam$", "", colnames(countdata))
  colnames(countdata) <- gsub("\\.", "-", colnames(countdata))
# Sort countdata by P. damicornis gene ID
countdata_sorted_coral <- as.data.frame(countdata[order(rownames(countdata)),])
```
```{r remove_baseline_samples}
coldata <- coldata %>% 
  filter(Treatment != "Baseline") 
countdata_sorted_coral <- countdata_sorted_coral %>% 
  dplyr::select(!contains("Baseline")) 
```
```{r coral_gene_annotation}
gene_annotation_coral <- read.delim(file = "./data/pdam_genome_annotations.tsv", header = T) %>% arrange(ID)
rownames(gene_annotation_coral) <- gene_annotation_coral$ID
# Check gene feature annotation and countdata rowname order coherence
all(rownames(countdata_sorted_coral) == gene_annotation_coral$ID)
all(rownames(countdata_sorted_coral) ==  rownames(gene_annotation_coral))
# Obtain KOG annotations for P. damicornis genome
gene2kog_coral <- gene_annotation_coral %>%
  dplyr::select(ID, KOG_Class) %>% 
  filter(KOG_Class != "")
```

## Import *Cladocopium* algal symbiont counts data and gene annotation
Not possible yet, alignments to Cladocopium genome pending
```{r symbiont_countdata}
# # Import and tidy counts data
# countdata <- read.delim("./outputs/SymC1_counts/AxH_SymC1.counts", comment.char="#")
# ## Tidy counts data
# #Set Gene ID's as row names
# row.names(countdata) <- countdata$Geneid
# # Remove first six columns (Geneid, chr, start, end, strand, length)
# countdata <- countdata[ ,7:ncol(countdata)]
# #countdata <- countdata[ ,6:ncol(countdata)]
# # Remove file prefixes and suffixes
#   colnames(countdata) <- gsub("X.", "", colnames(countdata))
#   colnames(countdata) <- gsub("scratch.projects.transcriptomics.mikeconnelly.projects.EAPSI_Symbiodinaceae.outputs.STARalign_SymC1.", "", colnames(countdata))
#   colnames(countdata) <- gsub("_SymC1Aligned.out.bam$", "", colnames(countdata))
#   colnames(countdata) <- gsub("_SymC1_[1-4]Aligned.out.bam$", "", colnames(countdata)) # removes extra suffixes from multiple rounds of alignment and quantification
# # Sort countdata by Cladocopium goreaui gene ID
# countdata_sorted_symbiont <- as.data.frame(countdata[order(rownames(countdata)),])
```
```{r symbiont_gene_annotation}
gene_annotation_symbiont <- read.delim("./data/cladocopium_genome_annotations.tsv", header = T) %>% arrange(ID)
rownames(gene_annotation_symbiont) <- gene_annotation_symbiont$ID
# Check gene feature annotation and countdata rowname order coherence
all(rownames(countdata_sorted_symbiont) == gene_annotation_symbiont$ID)
all(rownames(countdata_sorted_symbiont) == rownames(gene_annotation_symbiont))
# Obtain KOG annotations for Cladocopium goreaui genome
gene2kog_symbiont <- gene_annotation_symbiont %>% dplyr::select(ID, KOG_Class) %>% dplyr::filter(KOG_Class != "")
```

## Create DESeq datasets
### *Pocillopora* coral host
```{r create_dds_coral}
# Create full DESeqDataSet
dds_coral <- DESeqDataSetFromMatrix(countData = countdata_sorted_coral,
                              colData = coldata,
                              design = ~ Treatment)
# Check annotation and dds_coral object rowname order coherence
all(rownames(dds_coral) == rownames(gene_annotation_coral))
# Add gene feature annotation to DESeqDataSets
mcols(dds_coral) <- cbind(mcols(dds_coral), gene_annotation_coral)
# Subset DESeqDataSet
# Remove genes with counts less than 10 in 90% of samples
keep <- rowSums(counts(dds_coral) >= 10) > (ncol(countdata_sorted_coral)*0.9)
dds_coral <- dds_coral[keep, ]
# Normalize expression data for visualization purposes using VST tranformation
vsd_coral <- vst(dds_coral, blind = TRUE) # use blind = TRUE to not account for experimental design
```
### *Cladocopium* algal symbiont
```{r create_dds_symbiont}
# Create full DESeqDataSet
dds_symbiont <- DESeqDataSetFromMatrix(countData = countdata_sorted_symbiont,
                              colData = coldata,
                              design = ~ Colony)
# Check annotation and dds_symbiont object rowname order coherence
all(rownames(dds_symbiont) == rownames(gene_annotation_symbiont))
# Add gene feature annotation to DESeqDataSets
mcols(dds_symbiont) <- cbind(mcols(dds_symbiont), gene_annotation_symbiont)
# Subset DESeqDataSet
# Remove genes with counts less than 10 in 90% of samples
keep <- rowSums(counts(dds_symbiont) >= 10) > (47*0.9)
dds_symbiont <- dds_symbiont[keep, ]
# Normalize expression data for visualization purposes using VST transformation
vsd_symbiont <- vst(dds_symbiont, blind = TRUE) # use blind = TRUE to not account for experimental design
```

## Visualize global gene expression
```{r choose_vsd, include=FALSE}
# Choose vsd for host/symbiont analysis with PCoA and WGCNA
vsd <- vsd_coral
# vsd <- vsd_symbiont
```
```{r}
DESeq2::plotPCA(vsd_coral, intgroup = c("Symbiont_Genus")) 
```

### Principal Coordinate Analysis (PCoA)
  Must choose a vsd object (coral or symbiont) to use for the PCoA 
```{r mds, eval = TRUE}
# Calculate distances among samples
sampleDists <- dist(t(assay(vsd)), method = "manhattan")
sampleDistMatrix <- as.matrix(sampleDists)
# Calculate MDS
mds <- as.data.frame(colData(vsd)) %>% 
  cbind(cmdscale(sampleDistMatrix))
# Calculate MDS and use eigenvectors to determine proport
mds_eig <- cmdscale(sampleDistMatrix, eig = TRUE)
mds_eigenvectors <- data.frame(mds_eig$eig) %>% 
  mutate(prop_var = mds_eig.eig / sum(mds_eig.eig))
# create axis labels for plotting
xlab <- paste("PC1 (", round(mds_eigenvectors$prop_var[1]*100, digits = 1), "%)", sep = "")
ylab <- paste("PC2 (", round(mds_eigenvectors$prop_var[2]*100, digits = 1), "%)", sep = "")
# Calculate Colony centroids for plotting
mds_col <- mds %>% 
  group_by(Genotype) %>%
  dplyr::summarise(c1 = mean(`1`), c2 = mean(`2`)) %>%    
  full_join(mds)
# set factor orders 
# mds_col$Colony <- factor(mds$Colony, levels = c("HW1", "HW2", "WT1", "WT2"), ordered = TRUE)
# mds_col$Treatment <- factor(mds$Treatment, levels = c("control", "Heat", "Antibiotics", "Antibiotics.Heat"), ordered = TRUE)
# Calculate Treatment centroids for plotting
mds_trmt <- mds %>%
  group_by(Treatment) %>%
  dplyr::summarise(c1 = mean(`1`), c2 = mean(`2`)) %>%    
  full_join(mds)
#set factor orders 
# mds_trmt$Colony <- factor(mds_trmt$Colony, levels = c("HW1", "HW2", "WT1", "WT2"), ordered = TRUE)
# mds_trmt$Treatment <- factor(mds_trmt$Treatment, levels = c("control", "Heat", "Antibiotics", "Antibiotics.Heat"), ordered = TRUE)
```
```{r pcoa_treatment}
pcoa_treatment_coral <- ggPCoA(mds_trmt)
# pcoa_treatment_symbiont <- ggPCoA(mds_trmt)
# 
# Save single treatment PCoA plot
pcoa_plot <- pcoa_treatment_coral
# pcoa_plot <- pcoa_treatment_symbiont
#
pdf(file = "./outputs/DESeq_results/figures/pcoa_treatment.pdf", width = 6, height = 4)
print(pcoa_plot)
dev.off()
```

## Differential gene expression analysis (DESeq2)
  Must choose a dds object and gene annotation (coral or symbiont) to use for the PCoA 
```{r choose_dds_annotation}
# # Choose DESeq dataset and annotation for coral or symbiont differential gene expression analysis
dds <- dds_coral
gene_annotation <- gene_annotation_coral
partner <- "coral"
# #
# dds <- dds_symbiont
# gene_annotation <- gene_annotation_symbiont
# partner <- "symbiont"
```
```{r genotype_DESeq}
#First, genotype-specific treatment models
design(dds) <- formula(~ Treatment)
#Set control treatment as reference factor level
dds$Treatment <- factor(dds$Treatment, levels = c("Control", "Antibiotics"))
dds$Genotype.Treatment <- relevel(dds$Genotype.Treatment, ref = "URA-51.Control")
#Perform DESeq2 analysis
dsr1 <- DESeq(dds)
resultsNames(dsr1)
# Define contrasts
contrasts <- tibble(num = c("Antibiotics"), 
                    den = c("Control"))
# Create tibble with DESeq results for all treatment contrasts for each colony
DE <- crossing(Genotype = c("PAN-78", "PAN-79", "PAN-83"), contrasts) %>%
   mutate(dsr = pmap(list(Genotype, num, den), function(x, y, z) {
   results(dsr1, contrast = c("Genotype.Treatment", paste0(x, ".", c(y, z))))}))

#
```
```{r}
res <- results(dsr1, name = "Treatment_Antibiotics_vs_Control")
summary(res)
rownames(res)[res$padj < 0.05]

DE <- data.frame(res) %>%
  rownames_to_column("ID") %>% 
  left_join(gene_annotation, by = "ID") %>% 
  filter(padj < 0.05)
```
```{r overall_DESeq}
#Second, overall colony and treatment interaction model
# ~ Batch + Colony + Treatment + Colony:Treatment
design(dds) <- formula(~ Batch + Colony + Treatment)
#Set control treatment as reference factor level
dds$Treatment <- factor(dds$Treatment, levels = c("control", "Antibiotics", "Heat", "Antibiotics.Heat"))
dds$Treatment <- relevel(dds$Treatment, ref = "control")
#Perform DESeq2 analysis
dsr2 <- DESeq(dds)
resultsNames(dsr2)
# Get DESeq results for all treatment contrasts
DE <- crossing(Colony = "all", contrasts) %>%
  mutate(dsr = map2(num, den, ~ results(dsr2, contrast = c("Treatment", .x, .y)))) %>%
  bind_rows(DE)
```
```{r DE_table}
DE <- DE %>%
  mutate(df = map(dsr, ~ rownames_to_column(data.frame(.), "ID")),
         df = map(df, ~ left_join(., gene_annotation, by = "ID")))

# Filter out significant up and down-regulated genes
DE <- DE %>%
  mutate(sig = map(df, ~ filter(., padj < 0.05)),
          up = map(sig, ~ filter(., log2FoldChange > 0)),
        down = map(sig, ~ filter(., log2FoldChange < 0))) 

# Generate signed logP values for KOG MWU tests of all differential expression contrasts 
DE <- DE %>% mutate(logP = map(dsr, ~ data.frame(
  gene = rownames(data.frame(.)),
  logP = -log10(data.frame(.)$pvalue) * sign(data.frame(.)$log2FoldChange))))

# Generate binary values for KOG Fisher's tests of all differential expression contrasts
# Upregulated genes = 1, all others = 0
DE <- DE %>%
  mutate(sig_binary_up = map(dsr, ~ data.frame(
    gene = rownames(data.frame(.)),
    value = ifelse(data.frame(.)$padj < 0.05 & data.frame(.)$log2FoldChange > 0, 1, 0))))

# Downregulated genes = 1, all others = 0
DE <- DE %>%
  mutate(sig_binary_down = map(dsr, ~ data.frame(
    gene = rownames(data.frame(.)),
    value = ifelse(data.frame(.)$padj < 0.05 & data.frame(.)$log2FoldChange < 0, 1, 0))))
```
```{r DE_check}
DE
warnings()
```
```{r DE_store}
# Store DE results tibbles
# DE_coral <- DE
# DE_symbiont <- DE
```
```{r DE_load}
# DE <- DE_coral
# DE <- DE_symbiont
```
```{r DEG_contrasts_table}
# Count number of differentially expressed genes within each colony, and overall, for each contrast
DEtab <- DE %>%
  mutate(nsig = map_dbl(sig, ~ nrow(.)),
         nup = map_dbl(up, ~ nrow(.)),
         ndn = map_dbl(down, ~ nrow(.)),
         `DEGs [up, down]` = paste0(nsig, " [", nup, ", ", ndn, "]")) %>%
  mutate(Colony = factor(Colony, levels = c("HW1", "HW2", "WT1", "WT2", "all"), ordered = TRUE),
         num = factor(num, levels = c("Heat", "Antibiotics", "Antibiotics.Heat"), ordered = TRUE),
         den = factor(den, levels = c("control", "Heat", "Antibiotics"), ordered = TRUE)) %>%
  arrange(Colony, num, den) %>% 
  filter(den == "control") %>% 
  mutate("Contrast" = paste0(num, " vs. ", den)) %>% 
  dplyr::select(Colony, Contrast, `DEGs [up, down]`) %>% 
  pivot_wider(names_from = Colony, values_from = `DEGs [up, down]`)
```
```{r DE_contrasts_summary_table}
# Store DE results tables
# DEtab_coral <- DEtab
DEtab_symbiont <- DEtab
```
```{r Table_1}
# Bind together coral and symbiont DEG contrast results
# DE_table <- bind_rows("Pocillopora" = DEtab_coral, "Cladocopium" = DEtab_symbiont, .id = "Holobiont Partner")
# Write output to file
# DE_table %>%
#   write_csv("./outputs/DESeq_results/tables/DE_table.csv")
```
```{r Write_significant_results_tables}
# Write significant DEG results tables to csv files
DE %>%
  filter(den == "control") %>%
  mutate(sig_file_out = paste0(num, "_", den, "_", Colony, "_", partner, "_", "sig", ".csv"),
         sig_file_out_path = file.path("./outputs/DESeq_results/tables/sig/", sig_file_out),
         data = walk2(sig, sig_file_out_path, write_csv))
# Write ALL DEG results tables to csv files
DE %>%
  filter(den == "control") %>%
  mutate(file_out = paste0(num, "_", den, "_", Colony, "_", partner, "_", "all", ".csv"),
         file_out_path = file.path("./outputs/DESeq_results/tables/all/", file_out),
         data = walk2(df, file_out_path, write_csv))
```
```{r DE_master_results_table}
# Next, I want to bring together the overall model LFC and padj values for each treatment contrast into a single table.
DE_results <- DE %>%
  mutate(Colony = factor(Colony, levels = c("HW1", "HW2", "WT1", "WT2", "all"), ordered = TRUE),
         num = factor(num, levels = c("Heat", "Antibiotics", "Antibiotics.Heat"), ordered = TRUE),
         den = factor(den, levels = c("control", "Heat", "Antibiotics"), ordered = TRUE)) %>%
  arrange(Colony, num, den) %>% 
  # filter to include only overall contrasts against the control treatment
  filter(den == "control") %>% 
  filter(Colony == "all") %>%
  dplyr::select(num, den, df) %>% 
  unnest(df) %>%
  unite(contrast, num, den) %>% 
  dplyr::select(contrast, ID, log2FoldChange, padj) %>% 
  pivot_wider(names_from = contrast, values_from = log2FoldChange:padj) %>% 
  mutate(DE_Heat = ifelse(padj_Heat_control < 0.05 & log2FoldChange_Heat_control > 0, "UP", 
                            ifelse(padj_Heat_control < 0.05 & log2FoldChange_Heat_control < 0, "DOWN", "NA")),
         DE_Antibiotics = ifelse(padj_Antibiotics_control < 0.05 & log2FoldChange_Antibiotics_control > 0, "UP", 
                            ifelse(padj_Antibiotics_control < 0.05 & log2FoldChange_Antibiotics_control < 0, "DOWN", "NA")),
         DE_Antibiotics.Heat = ifelse(padj_Antibiotics.Heat_control < 0.05 & log2FoldChange_Antibiotics.Heat_control > 0, "UP", 
                            ifelse(padj_Antibiotics.Heat_control < 0.05 & log2FoldChange_Antibiotics.Heat_control < 0, "DOWN", "NA"))) %>% 
  left_join(gene_annotation, by = "ID")
# 
```
```{r DE_master_results_store}
# DE_results_coral <- DE_results
# DE_results_symbiont <- DE_results
write_csv(DE_results_coral, "./outputs/DESeq_results/tables/DE_results_coral.csv")
```
```{r DE_results_significant_DEGs}
DE_results_sig_coral <- DE_results_coral %>%
  filter(padj_Heat_control < 0.05 | padj_Antibiotics_control < 0.05 | padj_Antibiotics.Heat_control < 0.05)
#
DE_results_sig_coral %>% 
  filter(DE_Heat == DE_Antibiotics.Heat & DE_Antibiotics == DE_Antibiotics.Heat) %>% 
  write_csv(., path = "./outputs/DESeq_results/tables/DE_shared_treatments_coral.csv")
#
DE_results_sig_symbiont <- DE_results_symbiont %>%
  filter(padj_Heat_control < 0.05 | padj_Antibiotics_control < 0.05 | padj_Antibiotics.Heat_control < 0.05)
#
DE_results_sig_symbiont %>% 
  filter(DE_Heat == DE_Antibiotics.Heat & DE_Antibiotics == DE_Antibiotics.Heat) %>% 
  write_csv(., path = "./outputs/DESeq_results/tables/DE_shared_treatments_symbiont.csv")
```

## Weighted gene co-expression network analysis (WGCNA)
```{r wgcna_setup_datExpr}
allowWGCNAThreads(nThreads = 4)
# obtain vst-transformed counts
countdata_vst <- assay(vsd)
# Convert to matrix and transpose, check dimensions
datExpr <- t(countdata_vst)
dim(datExpr)
```
```{r soft_threshold}
# Find correlation power R^N that satisfies scale free critereon (SFT.R.sq>0.9)
sft <- pickSoftThreshold(datExpr, verbose=5)
sft$powerEstimate
```
### Step-by-step network construction
```{r adjacency_TOM}
# This follows the tutorial: 
# https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/FemaleLiver-02-networkConstr-man.pdf
# 
# I have chosen the following network construction parameters for the following reasons:
# First, following the recommendations of the WGCNA developers (https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/faq.html), a signed network was chosen to be able to detect positive and negative gene correlations, and the biweight midcorrelation was used since it is more robust to outliers. 

adjacency <- adjacency(datExpr,
      # Network construction arguments:  correlation, adjacency function,  and topological overlap map options
                       corFnc = "bicor", # bimidweight correlation
                       power = sft$powerEstimate, # 20 for coral, 5 for symbiont
                       type = "signed") # signed
# 
TOM <- TOMsimilarity(adjacency,
                     TOMType = "signed",
                     verbose = 5)
dissTOM <- 1-TOM
# 
rm(adjacency) # may need to delete adjacency, TOM to clear up vector memory
```
```{r gene_dendrogram}
geneTree <- flashClust(as.dist(dissTOM), method = "average")
plot(geneTree, labels = FALSE, xlab="", sub="", main = "Gene clustering on TOM-based dissimilarity")
```
```{r dynamic_treecut}
# minModuleSize = 100 because I prefer large modules that lend themselves to enrichment tests with GO_MWU for easier interpretation.
minModuleSize <- 30
# Module identification using dynamic tree cut, with cutHeight = 0.99 and deepSplit = 2 based on the recommendations of the WGCNA developers
dynamicMods <- cutreeDynamic(dendro = geneTree,
                             distM = dissTOM,
                             cutHeight = 0.99,
                             deepSplit = 2,
                             pamRespectsDendro = FALSE,
                             minClusterSize = minModuleSize)
table(dynamicMods)
# Convert numeric lables into colors
dynamicColors <- labels2colors(dynamicMods, colorSeq = standardColors())
```
```{r module_dendrogram}
# Calculate eigengenes
MEList <- moduleEigengenes(datExpr, colors = dynamicColors)
MEs <- MEList$eigengenes
# Calculate dissimilarity of module eigengenes
MEDiss <- 1-cor(MEs);
# Cluster module eigengenes
METree <- flashClust(as.dist(MEDiss), method = "average");
# Plot the result
plot(METree, main = "Clustering of module eigengenes",
xlab = "", sub = "")
MEDissThres = 0.15
# Plot the cut line into the dendrogram
abline(h=MEDissThres, col = "red")
```
```{r merge_modules}
# Call an automatic merging function
# merge cutHeight = 0.3 because I want to group together modules with >85% similar module eigengene expression
mergedMods <- mergeCloseModules(datExpr, dynamicColors, cutHeight = 0.15, verbose = 5)
# The merged module colors
mergedColors <- mergedMods$colors
table(mergedColors) 
```
```{r dendrogram_modules}
pdf(file = "./outputs/dendrogram_coral.pdf", width = 8, height = 6)
# pdf(file = "./manuscript_figures/FigS##_WGCNA_dendrogram.pdf", width = 8, height = 6)
# Plot the dendrogram and the module colors underneath
plotDendroAndColors(dendro = geneTree, 
                    colors = cbind(dynamicColors, mergedColors),
                    groupLabels = c("Dynamic modules", "Merged dynamic"),
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05,
                    abHeight = c(0.99))
```
```{r merged_eigengenes}
MEList <- moduleEigengenes(datExpr, colors = mergedColors)
mergedMEs <- MEList$eigengenes
```
```{r choose_modules}
moduleColors <- mergedColors#netColors#
MEs1 <- mergedMEs#netMEs#
# MEs1 <- MEs1 %>% select(-MEgrey)
MEmodule_colors <- colnames(MEs1)
module_colors <- gsub("ME", "", colnames(MEs1))
colnames(MEs1) <- module_colors
```
```{r ME_clustering}
datME <- MEs1
dissimME <- (1-t(cor(datME, method="p")))/2
hclustME <- flashClust(as.dist(dissimME), method="average" )
# Plot the eigengene dendrogram
par(mfrow=c(1,1))
plot(hclustME, main="Clustering tree based on the module eigengenes")
```
```{r uniq_modules}
# Extract all unique modules
uniqModules <- unique(colnames(MEs1))
# set in order according to ME clustering dendogram
hclustME$order
uniqModules <- uniqModules[hclustME$order]
#
uniqModules
# create ordered factor for downstream analysis
modules_factor <- factor(levels = uniqModules[hclustME$order], ordered = TRUE)
```
### Module genes and hub genes
```{r modules_genes}
# Generate GeneIDs
Genes <- colnames(datExpr)
# Output genes and annotations for each module
for (module in uniqModules)
{
# Select module genes
inModule <- (moduleColors == module)
# Get gene IDs
modGeneIDs <- Genes[inModule] #this is the correct set of gene IDs!
# Write gene annotations into a file
fileName = paste("./outputs/WGCNA_results/notes/", module, ".csv", sep="");
module_annotation <- gene_annotation[modGeneIDs, ]
write_csv(module_annotation, path = fileName)
}
```
```{r hub_genes}
hubs <- chooseTopHubInEachModule(datExpr,
                         mergedColors,
                         corFnc = "bicor", # bimidweight correlation
                         power=sft$powerEstimate, # 10
                         # power = 10,
                         type = "signed")
hub_genes <- gene_annotation[hubs, ]
hub_genes$module <- names(hubs)
row.names(hub_genes) <- NULL
hub_genes <- hub_genes %>% dplyr::select(module, everything())
```
```{r sig_hubs}
hub_genes <- hub_genes %>%
  # filter(module %in% sigModules) %>%
  dplyr::select(module, ID, Gene_Info) %>% 
  dplyr::rename("hub gene" = ID, "UniProt best match" = Gene_Info) 
```
```{r Table_2}
# hub_genes_coral <- hub_genes
# hub_genes_symbiont <- hub_genes
# Bind together coral and symbiont DEG contrast results
hub_genes_combined <- bind_rows("Pocillopora" = hub_genes_coral, "Cladocopium" = hub_genes_symbiont, .id = "Holobiont Partner")
# Write output to file
write_csv(hub_genes, path = "./outputs/WGCNA_results/hub_genes.csv")
```
```{r datkME}
#this section is adapted from Rachel Wright's GitHub: https://github.com/rachelwright8/Ahya-White-Syndromes/
colnames(MEs1) <- MEmodule_colors
datKME <- signedKME(datExpr, MEs1, outputColumnName = "") %>% rownames_to_column(., "ID")
genecolors <- data.frame(ID = Genes, moduleColor = moduleColors)
genecolors_kME <- left_join(genecolors, datKME, by = "ID") 
###
```
```{r kME_files}
# Assemble input for WGCNA GO_MWU: dataframe with gene IDs and kME values for all genes within a module, 0 for all genes without
for (module in uniqModules){
modkME <- genecolors_kME %>% dplyr::select(., "ID", "moduleColor", module)#paste("kME", module, sep = ""))
colnames(modkME) <- c("gene", "moduleColor", "kME")
###
modkME$kME[modkME$moduleColor!=module] <- 0  #also need to change column names for color you pick above
modkME$kME[modkME$moduleColor==module] <- 1 #leave commented out to keep kME values
modkME <- modkME %>% dplyr::select(., -moduleColor)
# write csv
#write.csv(modkME, file = paste("./outputs/WGCNA-results/tables/", module,"_kme.csv",sep=""), quote=F, row.names=F)
write.csv(modkME, file = paste("./R/GO_MWU/", module,"_kme_", partner, ".txt", sep=""), quote=F, row.names=F)
#repeat for each module
}
```
### Module eigengene correlations
```{r treatment_trait_data}
# Get sample data into tibble
datTraits <- coldata %>% rownames_to_column("Sample_ID") %>% select(Sample_ID)
datTraits$Control <- ifelse(coldata$Treatment == "Control", 1, 0)  
datTraits$Antibiotics <- ifelse(coldata$Treatment == "Antibiotics", 1, 0) 
datTraits <- datTraits %>% column_to_rownames(var = "Sample_ID")
  # dplyr::select(-Reef, -Colony, -Environment, -Treatment, -Batch, -allanti, -allheat, -Houwan, -Wanglitung) %>%
  # dplyr::select(SampleID, control, Heat, Antibiotics, Antibiotics.Heat) %>%
  # #dplyr::select(SampleID, HW1, HW2, WT1, WT2) %>%
  # arrange(SampleID) %>% #Order rows by sample name                         
  # column_to_rownames(var = "SampleID")
#Define numbers of genes and samples
nGenes <- ncol(datExpr)
nSamples <- nrow(datExpr)
```
```{r ME_correlations_treatments}
# Correlate module eigengene-trait associations
moduleTraitCor <- cor(MEs1, datTraits, use = "p")
moduleTraitPvalue <- corPvalueStudent(moduleTraitCor, nSamples)
moduleTraitCors <- as.data.frame(moduleTraitCor, moduleTraitPvalue)
```
```{r taxa_relative_abundance_traits}
# Combined analysis linking WGCNA modules and bacteria relative abundance
# # read in table with relative abundances of interesting bacteria taxa
# datTaxa_Family <- read_csv("./outputs/phyloseq-results/datTaxa_Family.csv")
# datTaxa_Family <- datTaxa_Family %>%
#   column_to_rownames("SampleID")
#   # dplyr::select(-Alteromonadaceae, -Endozoicomonadaceae)
```
```{r ME_correlations_taxa}
# moduleTaxaCor <- cor(MEs1, datTaxa_Family, use = "p")
# moduleTaxaPvalue <- corPvalueStudent(moduleTaxaCor, nSamples)
# moduleTaxaCors <- as.data.frame(moduleTaxaCor, moduleTaxaPvalue)
```
```{r sig_modules}
# Identify all unique and interesting modules based on trait correlations
# Filter for all the modules that have a significant correlation to any treatment, genotype, bacteria taxa, etc.
# p_values <- cbind(moduleTraitPvalue, moduleTaxaPvalue)
modP <- as.data.frame(moduleTraitPvalue) %>%
  rownames_to_column("module") %>%
  arrange(module) %>% 
  filter_all(any_vars(. < 0.05)) # %>% dplyr::select(module, lps)
sigModules <- sort(setdiff(modP$module,  "grey"))
# 
uniqModules
# would like to reorder the sigModules subset to match ME clustering dendrogram order
# sigModules <- uniqModules[uniqModules %in% sigModules]
# 
all(sigModules %in% uniqModules) # test that all the significant modules are actually within the modules
all(sigModules == uniqModules) # are all modules also significantly correlated to one or more traits?
sigModules
```
### Module gene significance (GS) and interconnectivity (kME)
```{r genesig}
# calculate gene trait significance for each treatment, genotype, etc.
geneTraitSignificance <- as.data.frame(cor(datExpr, datTraits, use = "p")) 
traitGS <- geneTraitSignificance %>% 
  rownames_to_column("ID")
```
```{r df_kME_GS}
longKME <- datKME %>% 
  # rename(gene = "ID") %>% 
  pivot_longer(cols= -ID, names_to = "module", values_to = "kME")
#
df_gene_GS_kME <- genecolors %>%
  # rename(gene = "ID") %>% 
  full_join(traitGS, by = "ID") %>% 
  full_join(longKME, by = "ID") %>%
  filter(moduleColor == module) %>%
  dplyr::select(-module)
```
```{r module_GS_kME_results_tables}
# write output tables with gene kME statistics and trait gene significance for each module
 for (module in uniqModules) {
# datKME <- datKME %>% column_to_rownames("gene")
df_mod_GS_kME <- df_gene_GS_kME %>%
  filter(moduleColor == module) %>% 
  dplyr::select(-moduleColor) %>% 
  dplyr::select(ID, kME, everything()) %>% 
  arrange(desc(kME)) %>% 
  left_join(., gene_annotation, by = "ID")
write_csv(df_mod_GS_kME, path = paste("./outputs/WGCNA_results/tables/", module, "_GS_kME.csv", sep = ""))
}
```

# Exploratory Analysis
```{r}
plotCounts(dds, "pdam_00023321", intgroup = c("Treatment", "Genotype"), returnData = TRUE) %>% ggplot(aes(Treatment, count, color = Genotype)) + geom_boxplot(aes(color = Genotype)) + geom_point()
```
```{r}
plotCounts(dds, "pdam_00007869", intgroup = c("Treatment", "Genotype"), returnData = TRUE) %>% ggplot(aes(Treatment, count, color = Genotype)) + geom_boxplot(aes(color = Genotype)) + geom_point()
```

```{r}
genes <- c("pdam_00000157", "pdam_00017622", "pdam_00014210", "pdam_00012950", "pdam_00012548", "pdam_00015711", "pdam_00017873", "pdam_00006916")
for (gene in genes) {
plot <- plotCounts(dds, gene, intgroup = c("Treatment", "Genotype"), returnData = TRUE) %>% ggplot(aes(Treatment, count, color = Genotype)) + geom_boxplot(aes(color = Genotype)) + geom_point()
print(plot)
}
```

